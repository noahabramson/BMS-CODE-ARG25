My first PyBMS API Program
===================================
PyBMS API was created to facilitate BMS IC communication with a higher level interface over traditional interfaces (Python over C/C++).
This to enable a more user friendly way of interfacing with the BMS IC's.
In this simple first PyBMS tutorial a simple program is written which sets the initial reference voltage for the cell readings and then reads out the cell voltages.
Before you can deepdive into the actual code, a few things need to be setup.

Install PyBMS
--------------
Please read the guide in user/Installation to install PyBMS API. After the API has
properly been installed and PyCharm CE has been configured, we can start with the hardware setup.

Hardware Setup
--------------
So for the setup, the following things are needed:

- SDP-K1 for interfacing between the test device and the computer/laptop Note that here the SPI cable is not plugged in correctly!
- A test device (This example uses the Lynx 18 Eval board +resistor string)
- 25V/0.5A power supply (depending on the device you are using. ADBMS2950 can be powered via USB)
- An IsoSPI cable, shielded twisted pairs
- Some test hooks to power the IC

.. image:: ../_static/img/lynx_connected_to_sdpk1.png
  :width: 600
  :alt: SDP_K1 drive on computer

Code structure
-----------------
You can find the code examples in the scratchpads folder. For convenience it is recommened to keep
the same structure. For example, an example on Lynx18 should be in scratchpads/ADBMS6842. However, for
the functionality, this is not required.

The concept of the scripts in PyBMS all are based on the following components:

1. creating an interface,
2. creating a command list
3. sending the command list to the device
4. Process the data (optional)

Creating an interface
----------------------
The interface part is easy, you select the interface you want to use, define which device you are using and which comport your SDPK1 is connected to.
There are a variety of interfaces available, to see them all, go to dev/Engine/Interfaces this will give you a list.
Most of the time, USB TO SPI BYTE is used or Virtual SPI.
For USB TO SPI BYTE, you need to select which comport is connected to the SDP-K1.
You can do this by running the dev/util/show_comports.py script or by opening device manager and looking at the serial busses.
Fill the comport in as the first parameter of the interface.

.. code-block:: python
   :name: interface_0

    interface = USB_TO_SPI_BYTE('COM5', 115200, stdout=False)
    bms = BMS(interface)
    board_list = [{'Device': ADBMS6837_REVA}]


Command list
----------------------
The command list is the hard of PyBMS. Here we define which commands we are going to send to the device. These commands are send to all devices in the chain. These commands can be find in the datasheet of the selected device. In the case of Lion (6830), there is even a whole list of all the commands that can be used! That can be found on Table 51. Command Codes. The syntax of the commands in the command list is as follows:

.. code-block:: python
   :name: command_0

    {'command': 'The name of the command', "arguments": {the bitfields that can be selected, for example 'CONT': True, "map_key": "the key where the results are written to"}},

For example, in the case of:

.. code-block:: python
   :name: command_1

    {'command': 'ADCV', "arguments": {"CONT": False, "RD": False}},

The command name is ADCV and the bitfields CONT (for continuous measurement) and RD (for redundant) measurement are both False.

Results
---------
The results are returned in a dict. The format of this is as follows:

.. code-block:: python
   :name: command_2

    results[loop number][map key][device number][key of value]


- **Loop number**: int, in case you are using the loop functionality, this will be the measurement number you did. In case you don't run a loop, this value doesn't exist and you can remove loop number all together
- **Map key**: str, this is the key where you mapped your value to. For example 'Current'. This is the value you can choose yourself. It is possible to write multiple value to the same map_key, but if they overwrite only the latest will remain
- **Device_number**: int, in case you only using one device, this value will be zero. The next device will have a one etc
- **Key of value**: str, this is the most complicated value. This is the name of the value on how it is written. For example, pec_match, I1, I2, OC1TH. These names should be the same as in the datasheet, but sometimes or not exactly up to date.

This will for example be the value of I1 of the first device in the chain.

Cell measuring scratchpad
----------------------------------
Now lets go to an example. For every eval board or test device, scratchpads are made. These scratchpads are example code scripts of all the different functions of an IC. All scratchpads are located in scratchpad directory.  As here we are using the Lynx as our Device under Test (DUT), head on over to the ADBMS6837 directory inside the scratchpad directory. Go to ADBMS6837_Cell_data.py, *if it does not exist, go ahead and copy the code below and store it in a new scratchpad.*

.. code-block:: python
   :name: command_3

    from Engine.BMS import BMS
    from Engine.Devices.ADBMS6837_REVA import ADBMS6837_REVA
    from Engine.Interfaces.USB_TO_SPI_BYTE import USB_TO_SPI_BYTE
    from pprint import pprint

    def main():
        # Start interface that connects to SDP-K1
        interface = USB_TO_SPI_BYTE('COM5', 115200, stdout=False)
        # Create bms object
        bms = BMS(interface)
        # Set device 0 = ADBMS6837_REVA (LYNX18)
        board_list = [{'Device': ADBMS6837_REVA}]


        command_list = [
            {"command": "$SPI_WAKEUP$", "arguments": {"Wakeup Time": 400}},
            {"command": "$DELAY_MS$", "arguments": {"Delay": 10}},
            {"command": "$SPI_WAKEUP$", "arguments": {"Wakeup Time": 10}},
            {"command": "WRCFGA", "arguments": {"REFON": True}}, #reference bit set to 1, IC pauses for T{refup} (4ms) to allow reference to power up.
            {"command": "ADCV", "arguments": {"CONT": True}}, #contininously execute conversion cycles according to the ADC command.
            {"command": "$DELAY_MS$", "arguments": {"Delay": 50}},
            {"command": "$SPI_WAKEUP$", "arguments": {"Wakeup Time": 10}},
            {"command": "$DELAY_MS$", "arguments": {"Delay": 200}},

            {"command": "SNAP"},
            {"command": "RDCVA", "map_key": "Cells"},
            {"command": "RDCVB", "map_key": "Cells"},
            {"command": "RDCVC", "map_key": "Cells"},
            {"command": "RDCVD", "map_key": "Cells"},
            {"command": "RDCVE", "map_key": "Cells"},
            {"command": "RDCVF", "map_key": "Cells"},
            {"command": "UNSNAP"},
        ]

        # Run results and close interview afterwards
        results = bms.run_generic_command_list(command_list, board_list)

        interface.close()

        # Print results with pretty print
        pprint(results)



    if __name__ == "__main__":
        main()


Command list
---------------
Looking at the command list, before the cells can be read a few things need to happen.
First the IC needs to wake up, this always needs to happen and is done with an SPI wake up and an added delay to wait for the device to wake up.
Then to be able to accurately measure the cell voltage, the reference voltage must be on.
This is done with the REFON argument of Config A.
This can all be found in the preliminary datasheet of Lynx page 44-70.
Then the Cell ADC is activated using the ADCV command with the continuous argument to enable continuous measurements.
Lastly the Cell voltages are read out using the RDCV* command in which the * indicates the cell group.
A indicates cell 1-3, B indicates 4-6 etc.
The cell value is then stored under the Key name *"Cells"*.

Results
------------
Running the script above will give you the following results:

- In key space "Cells", each cell value is displayed. As well as the cmd PEC and PEC status, indicating if the all packages were send and received correctly.
- In key space "Cells" also the Raw values are displayed.

.. code-block:: python
   :name: result_0

    C:\devme\venv\Scripts\python.exe C:/devme/scratchpads/ADBMS6837/SimpleScratchpads/ADBMS6837_Cell_Data.py
    {'All': [<Engine.Devices.BMS_Config.SPIWakeup object at 0x000001A6CAEB4CA0>,
             <Engine.Devices.BMS_Config.DELAY_MS object at 0x000001A6CAEB4EE0>,
             <Engine.Devices.ADBMS_GEN7.WRCFGA object at 0x000001A6CAEB4F10>,
             <Engine.Devices.ADBMS_GEN7.ADCV object at 0x000001A6CAEB5000>,
             <Engine.Devices.BMS_Config.DELAY_MS object at 0x000001A6CAEB5210>,
             <Engine.Devices.BMS_Config.SPIWakeup object at 0x000001A6CAEB5B10>,
             <Engine.Devices.BMS_Config.DELAY_MS object at 0x000001A6CAEB5D80>,
             <Engine.Devices.ADBMS_GEN7.SNAP object at 0x000001A6CAEB5DE0>,
             <Engine.Devices.ADBMS_GEN7.RDCVA object at 0x000001A6CAEB5E70>,
             <Engine.Devices.ADBMS_GEN7.RDCVB object at 0x000001A6CAEB5F30>,
             <Engine.Devices.ADBMS_GEN7.RDCVC object at 0x000001A6CAEB60B0>,
             <Engine.Devices.ADBMS_GEN7.RDCVD object at 0x000001A6CAEB6380>,
             <Engine.Devices.ADBMS_GEN7.RDCVE object at 0x000001A6CAEB6650>,
             <Engine.Devices.ADBMS_GEN7.RDCVF object at 0x000001A6CAEB6920>,
             <Engine.Devices.ADBMS_GEN7.UNSNAP object at 0x000001A6CAEB6BF0>],
     'Cells': [{'0': False,
                '1': True,
                'ADDR': 15,
                'C10V': 1.3914,
                'C11V': 1.39125,
                'C12V': 1.39065,
                'C13V': 1.39035,
                'C14V': 1.38975,
                'C15V': 1.3908,
                'C16V': 1.39005,
                'C17V': 1.3902,
                'C18V': 1.39155,
                'C1V': 1.3911,
                'C2V': 1.39095,
                'C3V': 1.3899,
                'C4V': 1.3908,
                'C5V': 1.3905,
                'C6V': 1.3899,
                'C7V': 1.39035,
                'C8V': 1.39035,
                'C9V': 1.3908,
                'CCNT': 1,
                'CMD PEC': 44656,
                'DATA PEC': 907,
                'Total_PEC_Status': True}],
     'Cells_RAW': [{'0': 0,
                    '1': 1,
                    'ADDR': 15,
                    'C10V': 64812,
                    'C11V': 64811,
                    'C12V': 64807,
                    'C13V': 64805,
                    'C14V': 64801,
                    'C15V': 64808,
                    'C16V': 64803,
                    'C17V': 64804,
                    'C18V': 64813,
                    'C1V': 64810,
                    'C2V': 64809,
                    'C3V': 64802,
                    'C4V': 64808,
                    'C5V': 64806,
                    'C6V': 64802,
                    'C7V': 64805,
                    'C8V': 64805,
                    'C9V': 64808,
                    'CCNT': 1,
                    'CMD PEC': 44656,
                    'DATA PEC': 907,
                    'Total_PEC_Status': None}],
     'Total_PEC_Status': True}

    Process finished with exit code 0

Extracting the data to a CSV
-------------------------------------
Extracting the data from the results is actually really easy, if you know how.
The following code snippet will extract all 18 cell values and write them to results.csv.
You can use this for any other cell map or argument you want to extract.

.. code-block:: python
   :name: result_1

    import pandas as pd

    Cdata =pd.DataFrame({key: value for (key,value) in results['Cells'][0].items() if key.startswith('C') & key.endswith('V')}, index=[0]).iloc[:, :Ncells] #Ncells is here 18

    Cdata.to_csv('results.csv', header=True)

Common pitfalls
------------------
#. Ensure that you have the isoSPI cable plugged into the MAIN isoSPI! If you have it in the AUX, it will not give any valid results.
#. Any result displaying 1.49V for all the cells indicates that you did not receive valid data. This could be of many reasons:
    #. See pitfall 1
    #. You have not powered the DUT board correctly, use a multimeter to test the voltage between Vp and GND.
    #. There is timing issue, you are reading the results before the measurement was done.
#. Be aware of the SPI_WAKEUP. IsoSPI will go the sleep if you have delay of more then 10 ms. After such a delay it is required to have a SPI_WAKEUP. If you forget this, your first command is usually ignored.
#. Be aware of delays. Some thing don't happend instanly. For example, SRST. After such command a delay is required.
#. Be aware that the SDP-K1 has a setting for 1.8V and 3.3V. The ADBMS6822 required 3.3V When you have a fresh SDP-K1 the jumper is set to 1.8V.
#. If you get connection timeout, check if the SDP-K1 does not have a red LED activated/blinking. If this is the case, reset the SDP-K1 and you are good to go.
