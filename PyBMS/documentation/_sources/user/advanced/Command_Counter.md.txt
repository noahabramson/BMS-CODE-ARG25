# Command Counter Check

As of PyBMS version 2.0.7, the Command Counter check is included. 
The processing of the command counter is done during the parsing.
So if your scripts use freerunning mode, your scripts might not benefit that much from this new feature. 
It works in a similiar way as the PEC Check. In the results you will be seeing `Total_CCNT_Status`. 
This indicates if the calculated CCNT (Command CouNTer) matches the one you get back from the device.
If this is the case, the status will be `True`. Otherwise, `False` will be indicated.

Be aware, the name suggests the status is either sticky or checks the complete command_list.
This is not the case. It only checks it per command.
However, if one command is skipped, the CCNT also mismatches the following commands. Therefore it acts kinda of sticky.

## How to use the Command Counter Check

This part is really easy. You don't have to do anything! You just run your normal command list via `bms.run_generic_command_list`.
However, there are few things to be aware of. It is recommended that you start your script with either `SRST` or `RSTCC`.
If you don't do this and you have a pack monitor (the pack monitor does not go to sleep where the cell monitor does) in your chain,
your pack monitor might have a difference counter then your cell monitor. 

Although the CCNT is calculated for every device, your start value could be different.
For example, if you run your script ones, all the counters are the same. But if you then run your script > 2 s later, your cell monitors have been resetted.
Therefore the CCNT is 0. But your pack monitor still has to previous value. Therefore, the calculated CCNT is wrong.

## Advanced features

So what if you don't want to reset your CCNT via `SRST` or `RSTCC`? Well, then there is an option! You can set the calculated CCNT via your `board_list`. 
This works as follows:

 ```python
# Create bms object as normal. After the creation of the object, there is an empty list that you can access via bms.saved_board_list
bms = BMS(interface)
# Create a board_list as normal
board_list = [{'Device': ADBMS2950},{'Device': ADBMS6832}]
# Run the generic command list
results = bms.run_generic_command_list(command_list, board_list, include_raw=False)

# After you ran the generic command list, the saved_board_list is populated. You can access and alter if needed
tiger_ccnt_after_running = bms.saved_board_list[0]['CCNT']
# Setting the ccnt of Tiger. If you want to alter the CCNT of lion, simply change the 0 to a 1
bms.saved_board_list[0]['CCNT'] = 22
 ```

It is for example also possible to reverse this board_list. The can be useful when working with a chain that works in forward and reverse!
This can be done with:

```python
bms.saved_board_list = bms.saved_board_list[::-1]
```

And that is all you need to know about the command counter check! Happy coding!