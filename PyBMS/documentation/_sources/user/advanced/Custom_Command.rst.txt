Custom Command
==================
In some cases it might be necessary to add a custom command. In general all commands are added to all the devices, but if for some reason
you need to test a custom command, this is how you add it.

Local Custom Command
----------------------
This feature lets you define locally a test command.
You can just add the example in your scatchpad.
The advantage of this, is that you
The PEC data is already calculated so you don't have to worry about this

.. code-block:: python
   :name: Define custom command
    # Import the test commmand
    from Engine.Devices.ADBMS_TEST_DEVICE import *

    # Define a board. For example the ADBMS2950
    board = ADBMS2950

    # Define a board list as normal
    board_list = [{"Device": board}]

    # Dynamicly add the bitfields and registers to the command. You don't have to change anything here.
    board.BITFIELDS.update({TEST_BITFIELD.NAME: TEST_BITFIELD})
    board.MEMORY_MAP.update({TEST_REGISTER0.NAME: TEST_REGISTER0})
    board.MEMORY_MAP.update({TEST_REGISTER1.NAME: TEST_REGISTER1})
    board.MEMORY_MAP.update({TEST_REGISTER2.NAME: TEST_REGISTER2})
    board.MEMORY_MAP.update({TEST_REGISTER3.NAME: TEST_REGISTER3})
    board.MEMORY_MAP.update({TEST_REGISTER4.NAME: TEST_REGISTER4})
    board.MEMORY_MAP.update({TEST_REGISTER5.NAME: TEST_REGISTER5})
    # Add the command to your define (for example ADBMS2950)
    board.COMMANDS.update({TEST_RD_CMD.NAME: TEST_RD_CMD})
    board.COMMANDS.update({TEST_WR_CMD.NAME: TEST_WR_CMD})

Now you can use the test_rd_cmd or test_wr_cmd in your command list.
The kwargs are cmd_code and test_value. Here you can see an example

.. code-block:: python
   :name: Define custom command

    command_list = [
        {"command": "$SPI_WAKEUP$", "arguments": {"Wakeup Time": 400}},
        {"command": "$DELAY_MS$", "arguments": {"Delay": 10}},
        {"command": "test_wr_cmd", "cmd_code": 0x058e, "test_value": 0xFFFFFFFF}
        {"command": "test_rd_cmd", "cmd_code": 0x008e, "map_key": "val"}
    ]

Extra advanced: add command to device definition
----------------------------------------------------------------

If you want to add a command to the device definition, that is also possible.
To do that, open the device definition file in `Engine/Devices`
Then, create a new class that has the name of your command.
Make sure you select the right parent class.
Most likely this will be `bmsbase.SPIWRITE` or `bmsbase.SPIREAD`.
After this, you can populate the other fields as in the example.

.. code-block:: python
   :name: Add custom command

   class WRCFGA(bmsbase.SPIWrite):
       STATIC = [[CMD_REGISTER(), False], [CMD_PEC_REGISTER(), False]]
       STATIC_LENGTH = 4
       VARIABLE = [[CFGAR0(), False], [CFGAR1(), False], [CFGAR2(), False], [CFGAR3(), False], [CFGAR4(), False],
                   [CFGAR5(), False], [CCNT_REGISTER(), False], [DATA_PEC_REGISTER(), False]]
       VARIABLE_LENGTH = 8
       NAME = 'WRCFGA'
       DESCRIPTION = 'Write Configuration Group A'

       def __init__(self, **kwargs):
           super(WRCFGA, self).__init__(**kwargs)
           self.local_definitions = {
               CMD0.NAME: CMD0(value=0x00),
               CMD1.NAME: CMD1(value=0x01),
               CCNT.NAME: CCNT(value=0x00)
           }

After this, you need to add the registers (also known as bytefields).
This contains the bitfields. An example of this you can find here:

.. code-block:: python
   :name: Add custom register

   class CFGAR0(bmsbase.Register):
       MEM_KEY = 'Configuration Register Group A'
       NAME = 'CFGAR0'

       def __init__(self):
           super(CFGAR0, self).__init__(
               [[REFON, 0], [bmsbase.RSVD0, 0], [bmsbase.RSVD0, 0], [bmsbase.RSVD0, 0], [bmsbase.RSVD0, 0], [CTH, 2],
                [CTH, 1], [CTH, 0]])

As you can see, this register is filled with bitfields.
If you don't take existing bitfields, you have to define them. Here you can see the example:

.. code-block:: python
   :name: Add custom bitfield

   class CTH(bmsbase.BitfieldInt):
       NAME = 'CTH'
       DESCRIPTION = 'C vs S ADC Comparison Voltage Threshold'
       MEM_KEY = 'Configuration'
       DEFAULT_VALUE = 0
       MAX_VALUE = 0x7
       MIN_VALUE = 0
       LENGTH = 3
       LIMITS = {
           'range': [0, 1, 2, 3, 4, 5, 6, 7]
       }

       def __init__(self, value=0, raw_value=0):
           super(CTH, self).__init__(CTH.LENGTH, value=value, raw_value=raw_value)
           self.name = CTH.NAME

You actually don't have to give the LIMITS parameters. If you put {} in there, it will be limited by the LENGTH variable.
This can be useful if you have a 2 bit bitfield that can only take 1 and 2 for example.
The DESCRIPTION can be left an empty string since it is only required in the GUI.
The mem_key is the shown in the results dict.

What can go wrong?
You might be temped to take a shortcut incase your bitfield takes the full byte.
However, this will most likely lead to problems.
Writing might still work up to a certain level, but reading will most definitly throw errors.

Advanced: Variable Command
-----------------------------------
Let say you have a command that uses and address. It would be a waste if you have to add
a command for each address. Luckily, there is a shortcut for that.
You can define individual bits by calling bmsbase.Bit0 for 0 and bmsbase.Bit1 for a 1.
After that, you can also define bitfields. This can be useful if you want to add an address.
In the example, RD and OPT are the variable part. These are respectivicly 1 bit and 3 bits.
The bitfields of course have to be defined as well. You can see how in the example above.

.. code-block:: python
   :name: Variable Command


   class ADI1(bmsbase.SPIWrite):
       STATIC = [[bmsbase.Register(
           [[bmsbase.Bit0, 0], [bmsbase.Bit0, 0], [bmsbase.Bit0, 0], [bmsbase.Bit0, 0], [bmsbase.Bit0, 0],
            [bmsbase.Bit0, 0], [bmsbase.Bit1, 0], [RD, 0], [OPT, 3], [bmsbase.Bit1, 0], [bmsbase.Bit1, 0], [OPT, 2],
            [bmsbase.Bit0, 0], [bmsbase.Bit0, 0], [OPT, 1], [OPT, 0], ]), False], [CMD_PEC_REGISTER(), False]]
       STATIC_LENGTH = 4
       VARIABLE = []
       VARIABLE_LENGTH = 0
       NAME = 'ADI1'
       DESCRIPTION = 'Start I1/VB1 Conversion'

       def __init__(self, **kwargs):
           super(ADI1, self).__init__(**kwargs)

This block currently does not have a variable part. However, you can add this in the same way
as other commands.